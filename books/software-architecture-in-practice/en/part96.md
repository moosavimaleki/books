Commercial off-the-shelf components, open source software, publicly available apps, and networked services are all examples of independently developed elements. The complexity and ubiquity of integrating many independently developed elements into your system have spawned an entire industry of software tools, such as Apache Ant, Apache Maven, MSBuild, and Jenkins. For software, the payoffs can take the following forms: *  Decreased time to market (It should be easier to use someone else’s ready solution than to build your own.) *  Increased reliability (Widely used software should have its bugs ironed out already.) *  Lower cost (The software supplier can amortize development cost across its customer base.) *  Flexibility (If the element you want to buy is not terribly special-purpose, it’s likely to be available from several sources, which in turn increases your buying leverage.) An open system is one that defines a set of standards for software elements—how they behave, how they interact with other elements, how they share data, and so forth. The goal of an open system is to enable, and even encourage, many different suppliers to be able to produce elements. This can avoid “vendor lock-in,” a situation in which a single vendor is the only one who can provide an element and charges a premium price for doing so. Open systems are enabled by an architecture that defines the elements and their interactions.