Table 12.2 Tactics-Based Questionnaire for Testability Tactics Group Tactics Question Supported? (Y/N) Risk Design Decisions and Location Rationale and Assumptions Control and Observe System State Does your system have specialized interfaces for getting and setting values? Does your system have a record/playback mechanism? Is your system’s state storage localized? Does your system abstract its data sources? Can some or all of your system operate in a sandbox? Is there a role for executable assertions in your system? Limit Complexity Does your system limit structural complexity in a systematic way? Is there nondeterminism in your system, and is there a way to control or limit this nondeterminism? ### 12.4 Patterns for Testability Patterns for testability all make it easier to decouple test-specific code from the actual functionality of a system. We discuss three patterns here: dependency injection, strategy, and intercepting filter. #### Dependency Injection Pattern In the dependency injection pattern, a client’s dependencies are separated from its behavior. This pattern makes use of inversion of control. Unlike in traditional declarative programming, where control and dependencies reside explicitly in the code, inversion of control dependencies means that control and dependencies are provided from, and injected into the code, by some external source.