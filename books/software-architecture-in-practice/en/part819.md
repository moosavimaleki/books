Agile programming and architecture have not always been on the best of terms. The Agile Manifesto of 2001, the “Prime Directive” of the Agile movement, implies that architecture is emergent and does not need to be planned or designed up-front. It was (and still is) easy to find published treatments of Agile that declare that if you aren’t delivering working software, then you aren’t doing anything of value. It follows that if you’re working on an architecture, then you’re taking resources away from programming and, therefore, you’re doing nothing of value—architecture, schmarchitecture! Write the code, and the architecture will emerge organically. For medium to large systems, this view has inevitably collapsed under the harsh weight of experience. Solutions to quality attribute requirements cannot simply be “bolted on” to an existing system in an arbitrarily late stage of development. Solutions for security, high performance, safety, and many more concerns must be designed into the system’s architecture from the beginning, even if the first 20 planned incremental deliveries don’t exercise those capabilities. Yes, you can begin coding and yes, the architecture will emerge—but it will be the wrong one.