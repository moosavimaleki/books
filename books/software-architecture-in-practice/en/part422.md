In this pattern, there are four roles: *  A service (that you want to make broadly available) *  A client of the service *  An interface (used by the client, implemented by the service) *  An injector (that creates an instance of the service and injects it into the client) When an interface creates the service and injects it into the client, a client is written with no knowledge of a concrete implementation. In other words, all of the implementation specifics are injected, typically at runtime. Benefits: *  Test instances can be injected (rather than production instances), and these test instances can manage and monitor the state of the service. Thus the client can be written with no knowledge of how it is to be tested. This is, in fact, how many modern testing frameworks are implemented. Tradeoffs: *  Dependency injection makes runtime performance less predictable, because it might change the behavior being tested.