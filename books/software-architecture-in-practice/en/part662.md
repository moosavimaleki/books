The identification of interfaces is usually not performed equally across all design iterations. When you are starting the design of a greenfield system, for example, your first iterations will produce only abstract elements such as layers; these elements will then be refined in later iterations. The interfaces of abstract elements such as layers are typically underspecified. For example, in an early iteration you might simply specify that the UI tier sends “commands” to the business logic tier, and the business logic tier sends “results” back. As the design process proceeds, and particularly when you create structures to address specific use cases and QA scenarios, you will need to refine the interfaces of the elements that participate in these interactions. In some special cases, identifying the appropriate interfaces may be greatly simplified. For example, if you choose a complete technology stack or a set of components that have been designed to interoperate, then the interfaces will already be defined by those technologies. In such a case, the specification of interfaces is a relatively trivial task, as the chosen technologies have “baked in” many interface assumptions and decisions.