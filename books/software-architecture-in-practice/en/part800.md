Based on this process, a debt-reduction strategy (typically achieved through refactoring) is straightforward. Knowing the files implicated in the debt, along with their flawed relationships (as determined by the identified anti-patterns), allows the architect to fashion and justify a refactoring plan. If a clique exists, for example, a dependency needs to be removed or reversed, so as to break the cycle of dependencies. If unhealthy inheritance is present, some functionality needs to be moved, typically from a child class to a parent class. If a modularity violation is identified, the unencapsulated “secret” shared among files needs to be encapsulated as its own abstraction. And so forth. ### 23.3 Example We illustrate this process with a case study, which we call SS1, done with SoftServe, a multinational software outsourcing company. At the time of the analysis, the SS1 system contained 797 source files, and we captured its revision history and issues over a two-year period. SS1 was maintained by six full-time developers and many more occasional contributors.