Revision history. Knowing the history of a module, including its authors and particular changes, may help you when you’re performing maintenance activities. *  Mapping to source code units. This identifies the files that constitute the implementation of a module. For example, a module Account, if implemented in Java, might have several files that constitute its implementation: IAccount.java (an interface), AccountImpl.java (implementation of Account functionality), and perhaps even a unit test AccountTest.java. *  Test information. The module’s test plan, test cases, test harness, and test data are important to document. This information may simply be a pointer to the location of these artifacts. *  Management information. A manager may need information about the module’s predicted schedule and budget. This information may simply be a pointer to the location of these artifacts. *  Implementation constraints. In many cases, the architect will have an implementation strategy in mind for a module or may know of constraints that the implementation must follow.