This solution using a shared lock is easy to implement when the services are processes running on a single machine, and requesting and releasing a lock are simple memory access operations that are very fast and atomic. However, in a distributed system, two problems arise with this scheme. First, the two-phase commit protocol traditionally used to acquire a lock requires multiple messages to be transmitted across the network. In the best case, this just adds delay to the actions, but in the worst case, any of these messages may fail to be delivered. Second, service instance 1 may fail after it has acquired the lock, preventing service instance 2 from proceeding. The solution to these problems involves complicated distributed coordination algorithms. Leslie Lamport, quoted at the beginning of the chapter, developed one of the first such algorithms, which he named “Paxos.” Paxos and other distributed coordination algorithms rely on a consensus mechanism to allow participants to reach agreement even when computer or network failures occur. These algorithms are notoriously complicated to design correctly, and even implementing a proven algorithm is difficult due to subtleties in programming language and network interface semantics. In fact, distributed coordination is one of those problems that you should not try to solve yourself. Using one of the existing solution packages, such as Apache Zookeeper, Consul, and etcd, is almost always a better idea than rolling your own. When service instances need to share information, they store it in a service that uses a distributed coordination mechanism to ensure that all services see the same values.