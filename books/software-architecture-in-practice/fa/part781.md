*  Document the ways the architecture is allowed to change. In the examples mentioned earlier, this will usually mean adding new components and replacing components with new implementations. The place to do this is the variability guide discussed in [Section 22.6](ch22.xhtml#ch22lev1sec6) *  Generate interface documentation automatically. If you use explicit interface mechanisms such as protocol buffers (described in [Chapter 15](ch15.xhtml#ch15)), then there are always up-to-date definitions of component interfaces; otherwise, the system would not work. Incorporate those interface definitions into a database so that revision histories are available and the interfaces can be searched to determine what information is used in which components. #### Traceability Architecture, of course, does not live in a bubble, but in a milieu of information about the system under development that includes requirements, code, tests, budgets and schedules, and more. The purveyors of each of these areas must ask themselves, “Is my part right? How do I know?” This question takes on different specific forms in different areas; for example, the tester asks, “Am I testing the right things?” As we saw in [Chapter 19](ch19.xhtml#ch19), architecture is a response to requirements and business goals, and its version of the “Is my part right?” question is to ensure that those have been satisfied. Traceability means linking specific design decisions to the specific requirements or business goals that led to them, and those links should be captured in the documentation. If, at the end of the day, all ASRs are accounted for (“covered”) in the architecture’s trace links, then we have assurance that the architecture part is right. Trace links may be represented informally—a table, for instance—or may be supported technologically in the project’s tool environment. In either case, trace links should be part of the architecture documentation.