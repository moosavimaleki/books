Compared to code-based technical debt, architecture debt is often harder to identify because its root causes are distributed among several files and their interrelationships. If you have a cyclic dependency where the cycle of dependencies passes through six files, it is unlikely that anyone in your organization completely understands this cycle and it is not easily observable. For these kinds of complex cases, we need help, in the form of automation, to identify the architecture debt. We call the sets of elements that make outsized contributions to the maintenance costs of a system hotspots. Architecture debt leads to high maintenance costs due to high coupling and low cohesion. So, to identify hotspots, we look for anti-patterns that contribute to high coupling and low cohesion. Six common anti-patterns—which occur in virtually every system—are highlighted here: *  Unstable interface. An influential file—one representing an important service, resource, or abstraction in the system—changes frequently with its dependents, as recorded in the revision history. The “interface” file is the entry point for other system elements to use the service or resource. It is frequently modified due to internal reasons, changes to its API, or both. To identify this anti-pattern, search for a file with a large number of dependents that is modified frequently with other files.