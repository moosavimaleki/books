Some specific things to look for are the following categories of information: *  Usage. User roles versus system modes, internationalization, language distinctions. *  Time. Timeliness and element coordination. *  External elements. External systems, protocols, sensors or actuators (devices), middleware. *  Networking. Network properties and configurations (including their security properties). *  Orchestration. Processing steps, information flows. *  Security properties. User roles, permissions, authentication. *  Data. Persistence and currency. *  Resources. Time, concurrency, memory footprint, scheduling, multiple users, multiple activities, devices, energy usage, soft resources (e.g., buffers, queues), and scalability requirements. *  Project management. Plans for teaming, skill sets, training, team coordination. *  Hardware choices. Processors, families of processors, evolution of processors. *  Flexibility of functionality, portability, calibrations, configurations. *  Named technologies, commercial packages. Anything that is known about their planned or anticipated evolution will be useful information, too. Not only are these categories architecturally significant in their own right, but the possible change and evolution of each are also likely to be architecturally significant. Even if the requirements document you’re mining doesn’t mention evolution, consider which of the items in the preceding list are likely to change over time, and design the system accordingly.