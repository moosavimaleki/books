این نسل جدید چارچوب‌های RPC درباره این واقعیت که یک درخواست راه دور با یک فراخوانی تابع محلی متفاوت است، صریح‌تر هستند. به عنوان مثال، Finagle و Rest.li از آینده‌ها (وعده‌ها) برای کپسوله کردن اقدامات غیرهمزمانی که ممکن است شکست بخورند، استفاده می‌کنند. آینده‌ها همچنین مواردی را که نیاز دارید درخواست‌هایی را به چندین سرویس به صورت موازی ارسال کنید و نتایج آن‌ها را ترکیب کنید، ساده‌تر می‌کنند [[45](ch04.html#Eriksen2013gz)].

gRPC از جریان‌ها پشتیبانی می‌کند، جایی که یک تماس نه فقط شامل یک درخواست و یک پاسخ، بلکه مجموعه‌ای از درخواست‌ها و پاسخ‌ها در طول زمان است [[46](ch04.html#gRPC2015)].

برخی از این چارچوب‌ها همچنین کشف سرویس را فراهم می‌کنند—یعنی اجازه می‌دهند یک مشتری در چه آدرس IP و شماره پورتی می‌تواند یک سرویس خاص را پیدا کند. ما به این موضوع در ["مسیریابی درخواست"](ch06.html#sec_partitioning_routing) باز خواهیم گشت.

پروتکل‌های RPC سفارشی با یک قالب کدگذاری باینری می‌توانند عملکرد بهتری نسبت به چیزی عمومی مانند JSON بر روی REST داشته باشند. با این حال، یک API RESTful مزایای قابل توجه دیگری دارد: برای آزمایش و اشکال‌زدایی مناسب است (شما می‌توانید به سادگی با استفاده از یک مرورگر وب یا ابزار خط فرمان curl، بدون هیچ تولید کدی یا نصب نرم‌افزار، به آن درخواست ارسال کنید)، توسط تمام زبان‌های برنامه‌نویسی و پلتفرم‌های اصلی پشتیبانی می‌شود، و یک اکوسیستم وسیع از ابزارها در دسترس است (سرورها، حافظه‌های نهان، متعادل‌کننده‌های بار، پروکسی‌ها، دیوارهای آتش، ابزارهای نظارت، ابزارهای اشکال‌زدایی، ابزارهای آزمایش و غیره).