اگر n بسیار کوچک باشد (به عنوان مثال، یک ستون کشور ممکن است تقریباً 200 مقدار متمایز داشته باشد)،
آن بیت‌مپ‌ها می‌توانند با یک بیت به ازای هر ردیف ذخیره شوند. اما اگر n بزرگتر باشد، صفرهای زیادی
در اکثر بیت‌مپ‌ها وجود خواهد داشت (می‌گوییم که آنها پراکنده هستند). در آن حالت، بیت‌مپ‌ها می‌توانند علاوه بر این
با کدگذاری طول اجرا (run-length encoding) کدگذاری شوند، همانطور که در پایین [شکل 3-11](#fig_bitmap_index) نشان داده شده است. این می‌تواند کدگذاری
یک ستون را به طور قابل توجهی فشرده کند. شاخص‌های بیت‌مپ مانند اینها برای انواع پرس‌وجوهایی که در یک انبار داده رایج هستند بسیار مناسب هستند. به عنوان مثال: `WHERE product_sk IN (30, 68, 69):` بیت‌مپ‌های product_sk = 30، product_sk = 68 و product_sk = 69 را بارگذاری کنید، و
OR بیتی سه بیت‌مپ را محاسبه کنید، که می‌تواند بسیار کارآمد انجام شود. `WHERE product_sk = 31 AND store_sk = 3:` بیت‌مپ‌های product_sk = 31 و store_sk = 3 را بارگذاری کنید، و AND بیتی را محاسبه کنید. این
کار می‌کند زیرا ستون‌ها حاوی ردیف‌ها به همان ترتیب هستند، بنابراین بیت k-ام در بیت‌مپ یک ستون
مربوط به همان ردیفی است که بیت k-ام در بیت‌مپ ستون دیگر مربوط به آن است.