توجه داشته باشید که مرتب‌سازی هر ستون به طور مستقل معنی نخواهد داشت، زیرا در این صورت دیگر
نمی‌دانیم کدام موارد در ستون‌ها متعلق به همان ردیف هستند. ما فقط می‌توانیم یک ردیف را بازسازی کنیم زیرا
می‌دانیم که مورد k-ام در یک ستون متعلق به همان ردیفی است که مورد k-ام در ستون
دیگر است. بلکه، داده‌ها باید یک ردیف کامل در یک زمان مرتب شوند، حتی اگر به صورت ستونی ذخیره شوند.
مدیر پایگاه داده می‌تواند ستون‌هایی را که جدول باید بر اساس آنها مرتب شود، با استفاده از
دانش خود از پرس‌وجوهای رایج انتخاب کند. به عنوان مثال، اگر پرس‌وجوها اغلب محدوده‌های تاریخ را هدف قرار می‌دهند، مانند
ماه گذشته، ممکن است منطقی باشد که date_key را اولین کلید مرتب‌سازی قرار دهیم. سپس بهینه‌ساز پرس‌وجو می‌تواند
فقط ردیف‌های ماه گذشته را اسکن کند، که بسیار سریع‌تر از اسکن تمام ردیف‌ها خواهد بود. یک ستون دوم می‌تواند ترتیب مرتب‌سازی هر ردیفی را که در ستون اول مقدار یکسانی دارند،
تعیین کند. به عنوان مثال، اگر date_key اولین کلید مرتب‌سازی در [شکل 3-10](#fig_column_store) باشد، ممکن است
منطقی باشد که product_sk دومین کلید مرتب‌سازی باشد تا تمام فروش‌ها برای همان محصول در همان
روز در ذخیره‌سازی گروه‌بندی شوند. این به پرس‌وجوهایی که نیاز به گروه‌بندی یا فیلتر کردن فروش‌ها بر اساس
محصول در یک محدوده تاریخ خاص دارند، کمک خواهد کرد.