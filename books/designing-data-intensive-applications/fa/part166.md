### بهینه‌سازی‌های عملکرد

همانطور که همیشه، جزئیات زیادی برای عملکرد خوب یک موتور ذخیره‌سازی در عمل وجود دارد. به عنوان مثال، الگوریتم درخت LSM می‌تواند هنگام جستجوی کلیدهایی که در پایگاه داده وجود ندارند، کند باشد: شما باید memtable، سپس قطعات را تا قدیمی‌ترین آنها بررسی کنید (احتمالاً باید برای هر کدام از دیسک بخوانید) قبل از اینکه بتوانید مطمئن شوید که کلید وجود ندارد. برای بهینه‌سازی این نوع دسترسی، موتورهای ذخیره‌سازی اغلب از فیلترهای بلوم اضافی استفاده می‌کنند [[15](ch03.html#Bloom1970gl)]. (یک فیلتر بلوم یک ساختار داده با کارایی حافظه برای تقریب محتوای یک مجموعه است. می‌تواند به شما بگوید که آیا یک کلید در پایگاه داده ظاهر نمی‌شود، و بنابراین بسیاری از خواندن‌های غیرضروری دیسک برای کلیدهای غیرموجود را ذخیره می‌کند.)

همچنین استراتژی‌های مختلفی برای تعیین ترتیب و زمان‌بندی چگونگی فشرده‌سازی و ادغام SSTable‌ها وجود دارد. رایج‌ترین گزینه‌ها فشرده‌سازی مبتنی بر اندازه و سطح‌بندی شده هستند. LevelDB و RocksDB از فشرده‌سازی سطح‌بندی شده استفاده می‌کنند (از این رو نام LevelDB)، HBase از فشرده‌سازی مبتنی بر اندازه استفاده می‌کند، و Cassandra هر دو را پشتیبانی می‌کند [[16](ch03.html#CassandraCompaction)]. در فشرده‌سازی مبتنی بر اندازه، SSTable‌های جدیدتر و کوچکتر به طور متوالی با SSTable‌های قدیمی‌تر و بزرگتر ادغام می‌شوند. در فشرده‌سازی سطح‌بندی شده، محدوده کلید به SSTable‌های کوچکتر تقسیم می‌شود و داده‌های قدیمی‌تر به "سطوح" جداگانه منتقل می‌شوند، که اجازه می‌دهد فشرده‌سازی به صورت تدریجی‌تر پیش برود و فضای دیسک کمتری استفاده کند. 